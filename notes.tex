

\documentclass[]{article}
\usepackage[sfdefault]{FiraSans} %% option 'sfdefault' activates Fira Sans as the default text font
\usepackage[T1]{fontenc}

\renewcommand*\oldstylenums[1]{{\firaoldstyle #1}}

\usepackage{hyperref}
\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=black,
    urlcolor=black
}

\usepackage{tikz}
\usetikzlibrary{shapes.geometric, arrows, positioning}

\setlength\parindent{0pt}
\setlength{\parskip}{0.5\baselineskip}

\usepackage{amssymb}

\begin{document}
\title{Operating Systems and Systems Programming I (\emph{CPS1012})\\ Short Notes}
\author{Aiden Cachia}
\date{}

\maketitle
\tableofcontents
\pagebreak

\section{Intoduction}

\subsubsection*{What is an Operating System?}

An Operating System is a program that acts as an intermediary between a user of a computer and the computer hardware.

\subsubsection*{Operating System Goals}

\begin{itemize}
    \item Execute user programs and make solving user problems easier.
    \item Make the computer system convenient to use.
    \item Use the computer hardware in an efficient manner.
\end{itemize}

\subsubsection*{Computer System Structure}
\begin{itemize}
    \item Hardware.
    \item Operating System.
    \item Application programs.
    \item Users.
\end{itemize}

\subsection{Operating System Services}

\begin{itemize}
    \item User Interface (CLI, GUI, Touch-screen, batch)
    \item Program Execution
    \item I/O Operations
    \item File-system manipulation
    \item Communications (On Device, Network)
    \item Error Detection
    \item Resource Allocation
    \item Protection and Security
\end{itemize}

\subsubsection*{Command Line Interface}

Simple Interface where command is fetched from user, it is exectued and the output is displayed.

\subsubsection*{Graphical User Interface}
More user friendly design, making use of;
\begin{itemize}
    \item Mouse, Keyboard and monitor
    \item Icons representing files, programs, actions etc \dots
    \item Menus
\end{itemize}

\subsection{System Calls}

Ways to interact with the Operating System. They are typically written in a high level language (C or C++) and are used to request a service from the Operating System.

\subsubsection*{Implementation of System Calls}

\begin{itemize}
    \item A table of all is usualy stored in the System-call interface.
    \item The System-call interface invokes the system-call in OS kernel and returns the status of the system-call and any return values.
\end{itemize}

\subsubsection*{System Call Parameters}

\begin{itemize}
    \item Registers
    \item Block/table
    \item Stack
\end{itemize}

\subsubsection*{Types of System Calls}

\emph{Process Control}
\begin{itemize}
    \item Create process, terminate process
    \item End, abort
    \item Load, execute
    \item Get process attributes, set process attributes
    \item Wait for time
    \item Wait for event, signal event
    \item Allocate and free memory
    \item Dump memory
    \item Debugging
    \item Locking
\end{itemize}

\emph{File Management}
\begin{itemize}
    \item Create file, delete file
    \item Open, close
    \item Read, write, reposition
    \item Get file attributes, set file attributes
\end{itemize}

\emph{Device Management}
\begin{itemize}
    \item Request device, release device
    \item Read, write, reposition
    \item Get device attributes, set device attributes
    \item Logically attach or detach devices
\end{itemize}

\emph{Information Maintenance}
\begin{itemize}
    \item Get or set 
    \begin{itemize}
        \item time or date
        \item system data
        \item process, file or device attributes
    \end{itemize}
\end{itemize}

\emph{Communications}
\begin{itemize}
    \item Create, delete communication connection
    \item Send, receive messages
    \item Shared memory
    \item Transfer status information
    \item Attach or detach remote devices
\end{itemize}

\subsection{System Services}

Helps in the development of programs. Some are just system-call interfaces, others more complex.

\subsubsection*{Types of System Services}
\begin{itemize}
    \item File management
        \subitem Create, delete, copy, rename, print, dump, list and generally manipulate files and directories.
    \item Status information
    \begin{itemize}
        \item Basic information (date, time, amount of available memory, disk space, number of users).
        \item Detailed logging and Debugging information.
        \item Registry to store and retrieve configuration information.
        \item File modification
        \item Program loading and execution
        \item Communications
    \end{itemize}
    \item Programming language support (Compilers, assemblers,
    debuggers and interpreters sometimes provided)
    \item Program loading and execution
    \item Communications
    \item Background services
    \begin{itemize}
        \item Launch at boot
        \item Provides facilities like disk checking, process scheduling, error logging, printing.
        \item Run in user context not kernel context
        \item Known as \emph{services}, \emph{subsystems} or \emph{daemons}
    \end{itemize}
    \item Application programs
    \begin{itemize}
        \item Unrelated to system
        \item Run by users
        \item Not part of OS
        \item Launched by CLI, Mouse click, finger poke
    \end{itemize}
\end{itemize}

\subsubsection*{Linkers and Loaders}

A Linker is used to link multiple object files (compiled from source code) into a single executable file.

A Loader is used to load the executable file into memory and start the execution of the program.

Relocation is the process of adjusting the addresses in the object file to match the addresses in memory.

Dynamic linked libraries (DLLs) are libraries that are linked at runtime, rather than at compile time, so they could be used by multiple programs that would require the same version of the library.

\subsubsection*{Why Applications are Operating System Specific}
System calls and file formats are different from one operating system to another, among other things. Because of this applications are not portable between operating systems without modification.

Applications can be made portable:
\begin{itemize}
    \item By using an interpreted language such as Python or Ruby;
    \item By using a language which include a VM such as Java;
    \item By using compiling a program which a User standard language (such as C), then recompiling it in target OSes.
\end{itemize}

An Application Binary Interface (ABI) is a specification defining requirements for an application on a specific hardware platform.

\subsection{Operating System Design}
There is no correct way to design an Operating System, but there are some common design principles.

An OS should have User goals (ease of use, convience, etc \dots) and System goals (efficiency, security, etc \dots).

\subsubsection*{Policy and Mechanism}

\emph{Policy} is what will be done, \emph{Mechanism} is how it will be done.

They should be seperate, as it would allow for maximum flexibility if policy decisions are to be chanced later.

\subsubsection*{Implementation}

Early OSes were written in Assembly, but now they only have the base of the OS writen in Assembly, and the rest written in high level languages such as C or C++.

Emulation allows for OS to run on non-native hardware.

\subsubsection*{The Kernel}

The Kernel is the core of the OS, which is used to manage system resources and provides essential services for all other parts of the OS and user-level programs.

Handles tasks such as:
\begin{itemize}
    \item Process management;
    \item Memory management;
    \item Scheduling;
    \item Interfacing with hardware devices.
\end{itemize}

\subsubsection*{Operating System Structure}

\begin{itemize}
    \item Simple Structure - MS-DOS
    \item More complex - UNIX
    \item Layered - an abstraction
    \item Microkernel - Mach
\end{itemize}

\subsubsection*{Monolithic - OG Unix}

\emph{Structure}
\begin{itemize}
    \item System Programs
    \item The kernel, which contains everything between the system-call interface and the hardware, providing File system, CPU scheduling, memory management, etc \dots
\end{itemize}

\subsubsection*{Layered}

Like an Onion, the Core being Hardware (Layer 0), and the outer being the User Interface (Layer N). Each layer only has access to the layers below it.

\subsubsection*{Microkernel}

A microkernel is the near-minimum amount of software that can provide the mechanisms needed to implement an OS.

\begin{itemize}
    \item Easier to extend a microkernel
    \item Easier to port the operating system to new architecture
    \item More reliable (less code is running in kernel mode)
    \item More secure
\end{itemize}

\subsubsection*{Modules}

Most modern OSes maks use of Loadable Kernel Modules (LKMs) which can be loaded and unloaded at runtime, Each:
\begin{itemize}
    \item uses Object-oriented approach;
    \item core component is seperate;
    \item talks to the other over known interfaces;
    \item is loadable as needed within the kernel.
\end{itemize}

\subsubsection*{Hybrid Systems}

Most modern OSes are hybrids of the above systems inorder to address performance, security and usability needs.

\subsubsection*{Dual-mode Operation}

Dual-mode operation allows OS to protect itself and other system components.

\emph{Mode bit} is used to distinguish between user and kernel mode, which is provided by hardware.

\section{Processes}

A \emph{process} is a program in execution. 

Its execution must be sequential. No parallel executution of a single process.

A program becomes a process once it is \textbf{active} and \textbf{loaded into memory}.

One program can have several processes. Consider mulitple users executing the same program.

\subsubsection*{Process Composition}

\begin{itemize}
    \item \emph{Text Section} - Program code
    \item \emph{Currect Activity} - Program counter, CPU registers
    \item \emph{Data Section} - Global variables
    \item \emph{Stack} - Temporary data (function parameters, return addresses, etc \dots)
    \item \emph{Heap} - Dynamically allocated memory
\end{itemize}

\subsubsection*{Process State}

\begin{itemize}
    \item \emph{New} - Process is being created
    \item \emph{Running} - Instructions are being executed
    \item \emph{Waiting} - Process is waiting for some event to occur
    \item \emph{Ready} - Process is waiting to be assigned to a processor
    \item \emph{Terminated} - Process has finished execution
\end{itemize}

\subsubsection*{Process Control Block}

\begin{itemize}
    \item \emph{Process State} - New, Ready, Running, Waiting, Terminated
    \item \emph{Program Counter} - Address of next instruction to be executed
    \item \emph{CPU Registers} - contents of all process-centric registers
    \item \emph{CPU Scheduling Information} - Priority, pointers to scheduling queues
    \item \emph{Memory Management Information} - Page tables, segment tables (memory allocated to the process)
    \item \emph{Accounting Information} - Amount of CPU and real time used, time limits, account numbers
    \item \emph{I/O Status Information} - List of I/O devices allocated to the process, list of open files
\end{itemize}

\subsubsection*{Threading}

TBD

\subsection{Process Scheduling}

The process scheduler selects whoch process to run in a way to maimize CPU utilization and throughput.

The Scheduler would have a \textbf{ready} queue with all processes in the ready state and a \textbf{wait} queue with all processes in the waiting state. The Processes migrate between the two queues. 

\subsubsection*{Context Switch}

When the CPU switches to another process, the system must save the state of the old process and load the saved state for the next process via a context switch.

Context-switch time is pure overhead; the system does no useful work while switching. The more complex the OS and the PCB, the longer the context switch time.


The time is dependent on hardware support. Some hardware provides multiple sets of registers per CPU so multiple contexts can be loaded at once.

\subsubsection*{Process Creation}

Process makes process which is his child, and those child create more child, making tree.
Process have a unique process ID, and is managed by it.

The options for resource sharing are:
\begin{itemize}
    \item Child Resources $=$ Parent Resources
    \item Child Resources $\subset$ Parent Resources
    \item Child Resources $\nsubseteq$ Parent Resources 
\end{itemize}

The options for execution are:
\begin{itemize}
    \item Parent and child execute concurrently
    \item Parent waits until child terminates
\end{itemize}

A child process is either a copy of the parent process or a new program.

\verb|fork()| Creates a new process by duplicating the calling process. 

\verb|exec()| system call used after a \verb|fork()| to replace the processâ€™ memory space with a new program

Parent process calls \verb|wait()| waiting for the child to terminate

Process executes last statement and then asks the operating system to delete it using the \verb|exit()| system call

Parent may terminate the execution of children processing using the \verb|abort()| system call. Some reasons for doing so:

\begin{itemize}
    \item Child has exceeded allocated resources
    \item Task assigned to child is not longer required
    \item The parent is exiting and the OS does not allow a child to continue if its parent terminates
\end{itemize}

Termination of a tree could be cascading or non-cascading.
\begin{itemize}
    \item Cascading - Parent process terminates all children
    \item Non-cascading - Parent process terminates, children continue to be terminated by the OS as it relizes the parent is gone.
\end{itemize}

If no parent is waiting (did not invoke \verb|wait()|) the process
becomes a zombie.
If the parent terminated without invoking \verb|wait()|, the
process becomes and orphan.

\end{document}